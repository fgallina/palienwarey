# -*- coding: utf-8 -*-
import collections

import usb.core

from .constants import VENDOR_ID, MODE_VERSION_1, MODE_VERSION_2

__all__ = ['MODE_VERSION_1', 'MODE_VERSION_2', 'registry', 'defmachine',
           'defmode', 'defzone', 'register_machine', 'defregister_machine']


# The registry of supported machines, add your machine generated by
# defmachine here and let the protocol do its magic.
registry = {}


def defmachine(uid, name, zones, mode_version):
    """
    Defines a machine.

    this function defines a new zone aliased 'all' using all the zones which
    are not a group or power and that can morph and pulse.

    Arguments:
      + uid: the last part of the bus id for the device as returned by lsusb.
      + name: name for the machine (ex: "Alienware 14 2013").
      + zones: an iterable of zones defined with defzone.
      + mode_version: One of the MODE_VERSION_* constants that define the
         available modes for device lights.

    Returns a dict with all passed arguments plus the following keys:
      + zones_by_uid: containing a dict mapping uids with zones.
      + modes: a list of supported modes as provided by mode_version.
      + device: slot reserved to save the usb device when it's found.
    """
    # Zone alias for all non-power nor group zones supporting all commands.
    all_zone = defzone(
        [zone['uid'] for zone in zones if not zone['is_power'] and
         not zone['is_group'] and zone['can_morph'] and zone['can_pulse']],
        'All zones (except power, non[morph|pulse] and group ones)',
        alias='all')
    zones = tuple(zones) + (all_zone,)

    # Defzones from MODE_VERSION_* values.
    modes = [defzone(*args) for args in mode_version]

    # Generate a lookup for zones by uid, useful in various places.
    zones_by_uid = {}
    for zone in zones:
        zones_by_uid[zone['uid']] = zone

    for zone in zones:
        if zone['is_group']:
            # Adjust group zone features so all members share the same
            # restrictions. For example if a member of a group cannot morph
            # then the whole group will not be able to morph (even if other
            # individual member where explicitly set to be able to).
            zone['can_morph'] = all(
                zones_by_uid[uid]['can_morph'] for uid in zone['uid'])
            zone['can_pulse'] = all(
                zones_by_uid[uid]['can_pulse'] for uid in zone['uid'])

    return {
        'uid': uid,
        'name': name,
        'zones': zones,
        'zones_by_uid': zones_by_uid,
        'modes': modes,
        # This is used to save the device found for the machine when using
        # get_machine to detect current system.
        'device': None
    }


def defmode(uid, name, alias=None):
    """
    Defines a power mode.

    Returns a dict with all passed arguments.
    """
    return {
        'uid': uid,
        'name': name,
        'alias': alias
    }


def defzone(uid, name, alias=None, can_morph=True, can_pulse=True,
            is_power=False):
    """
    Defines a zone with its specific capabilities.

    Arguments:
      + uid: uid (or iterable with uids) for the (group) zone (you can use
         lsdetect to detect them).
      + name: name for the zone (ex: "Keyboard: Middle Left").
      + alias: if provided, used for commandline switches.
      + can_morph: indicates if the zone can morph.
      + can_pulse: indicates if the zone can pulse.
      + is_group: as per protocol rules, you can define special zones (groups)
         by using the sum of uids as uid, for such zones make sure of setting
         is_group to True.
      + is_power: for the power zone there might be special rules, so this
         flag is just to identify them easily.

    For group zones, can_morph and can_pulse are re-set automatically when
    defining a new machine. The logic behind it is that when a member of a
    group cannot do something, for example morph, then the group will be
    marked with can_morph as False, even if some members of it do support it.

    Returns a dict with all the arguments, plus an is_group key that specifies
    if this is a group zone.
    """
    is_group = isinstance(uid, collections.Iterable)

    return {
        'uid': uid if not is_group else tuple(uid),
        'name': name,
        'alias': alias,
        'can_morph': can_morph,
        'can_pulse': can_pulse,
        'is_group': is_group,
        'is_power': is_power
    }


def register_machine(machine):
    """
    Adds machine to the global registry.
    """
    uid = machine['uid']
    if registry.get(uid) is None:
        registry[uid] = machine


def defregister_machine(name, uid, zones, mode_version):
    """
    Alias for register_machine(defmachine(*args)).

    Returns the registered machine.
    """
    machine = defmachine(name, uid, zones, mode_version)
    register_machine(machine)
    return machine


def get_machine():
    """
    Finds a registered usb machine and appends a valid usb device to it.

    Raises:
      + EnvironmentError: if cannot find a connected machine.

    Returns a machine instance.
    """
    tried = []
    for machine in registry.values():
        uid = machine['uid']
        tried.append(uid)
        device = usb.core.find(idVendor=VENDOR_ID, idProduct=uid)
        if device:
            machine['device'] = device
            return machine
    raise EnvironmentError('No machine found, tried: %s' % tried)
