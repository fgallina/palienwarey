# -*- coding: utf-8 -*-
import collections

import usb.core

from .constants import VENDOR_ID, MODE_VERSION_1, MODE_VERSION_2

__all__ = ['MODE_VERSION_1', 'MODE_VERSION_2', 'registry', 'defmachine',
           'defmode', 'defzone', 'register_machine', 'defregister_machine']


# The registry of supported machines, add your machine generated by
# defmachine here and let the protocol do its magic.
registry = {}


def defmachine(uid, name, zones, mode_version):
    """
    Defines a machine.

    this function defines a new zone aliased 'all' using all the zones which
    are not a group or power and that can morph and pulse.

    Arguments:
      + uid: the last part of the bus id for the device as returned by lsusb.
      + name: name for the machine (ex: "Alienware 14 2013").
      + zones: an iterable of zones defined with defzone.
      + mode_version: One of the MODE_VERSION_* constants that define the
         available modes for device lights.

    Returns a dict with all passed arguments plus the following keys:
      + zones_by_uid: containing a dict mapping uids with zones.
      + modes: a list of supported modes as provided by mode_version.
      + device: slot reserved to save the usb device when it's found.
    """
    all_zone = defzone(
        [zone['uid'] for zone in zones if not zone['is_power'] and
         not zone['is_group'] and zone['can_morph'] and zone['can_pulse']],
        'All zones (except power, non[morph|pulse] and group ones)',
        alias='all')
    zones = tuple(zones) + (all_zone,)

    modes = [defzone(*args) for args in mode_version]

    zones_by_uid = {}
    for zone in zones:
        zones_by_uid[zone['uid']] = zone

    return {
        'uid': uid,
        'name': name,
        'zones': zones,
        'zones_by_uid': zones_by_uid,
        'modes': modes,
        # This is used to save the device found for the machine when using
        # get_machine to detect current system.
        'device': None
    }


def defmode(uid, name, alias=None):
    """
    Defines a power mode.

    Returns a dict with all passed arguments.
    """
    return {
        'uid': uid,
        'name': name,
        'alias': alias
    }


def defzone(uid, name, alias=None, can_morph=True, can_pulse=True,
            is_power=False):
    """
    Defines a zone with its specific capabilities.

    Arguments:
      + uid: uid (or iterable with uids) for the (group) zone (you can use
         lsdetect to detect them).
      + name: name for the zone (ex: "Keyboard: Middle Left").
      + alias: if provided, used for commandline switches.
      + can_morph: indicates if the zone can morph.
      + can_pulse: indicates if the zone can pulse.
      + is_group: as per protocol rules, you can define special zones (groups)
         by using the sum of uids as uid, for such zones make sure of setting
         is_group to True.
      + is_power: for the power zone there might be special rules, so this
         flag is just to identify them easily.

    Returns a dict with all the arguments, plus an is_group key that specifies
    if this is a group zone.
    """
    is_group = isinstance(uid, collections.Iterable)

    return {
        'uid': uid if not is_group else tuple(uid),
        'name': name,
        'alias': alias,
        'can_morph': can_morph,
        'can_pulse': can_pulse,
        'is_group': is_group,
        'is_power': is_power
    }


def register_machine(machine):
    """
    Adds machine to the global registry.
    """
    uid = machine['uid']
    if registry.get(uid) is None:
        registry[uid] = machine


def defregister_machine(name, uid, zones, mode_version):
    """
    Alias for register_machine(defmachine(*args)).

    Returns the registered machine.
    """
    machine = defmachine(name, uid, zones, mode_version)
    register_machine(machine)
    return machine


def get_machine():
    """
    Finds a registered usb machine and appends a valid usb device to it.

    Raises:
      + EnvironmentError: if cannot find a connected machine.

    Returns a machine instance.
    """
    tried = []
    for machine in registry.values():
        uid = machine['uid']
        tried.append(uid)
        device = usb.core.find(idVendor=VENDOR_ID, idProduct=uid)
        if device:
            machine['device'] = device
            return machine
    raise EnvironmentError('No machine found, tried: %s' % tried)
